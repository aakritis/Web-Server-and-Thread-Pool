package edu.upenn.cis.cis455.webserver;

import org.apache.log4j.Logger;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Date;
import java.net.Socket;
import java.net.InetAddress;
import java.io.*;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.*;
import java.text.SimpleDateFormat;
import java.net.URL;

/**
 * Class for Worker thread.
 * 
 * Worker Thread reads Socket Objects from the shared queue as long as it is not empty.
 * After Reading the objects, it will process the client requests and send the response.
 */
@SuppressWarnings("unused")
public class WorkerThread extends Thread {

	// Using log4j framework for logging
	static final Logger logger = Logger.getLogger(WorkerThread.class);
	protected ArrayList<Socket> sharedQueue;
	protected ArrayList<Thread> threadPool;
	//protected Socket clientSocket = null;
	protected HashMap<String, String> mapRequestData = null;
	// to check that if head request is created , return only HTTP response headers
	boolean isHead = false;
	boolean isExpect = false;
	boolean isHTTPLatest = false;
	boolean isGet = false;
	boolean isModified = false;
	boolean isUnmodified = false;

	protected enum FileTypes {
		jpg , png , gif , txt , html ;
	}

	public WorkerThread (ArrayList<Socket> sharedQueue, ArrayList<Thread> threadPool)
	{
		this.sharedQueue = sharedQueue;
		this.threadPool = threadPool;
	}

	/**
	 * Method to read from the queue.
	 * @return - element read from queue
	 * @throws InterruptedException
	 */
	private Socket readFromQueue() {
		try{
			while (sharedQueue.isEmpty()) {
				//System.out.println(" [Output from log4j] Entering empty dequeue function ");
				//If the queue is empty, we push the current thread to waiting state. Way to avoid polling.
				synchronized (sharedQueue) {
					//logger.info(" [Output from log4j] Queue is currently empty ");
					//System.out.println(" [Output from log4j] Queue is currently empty ");
					sharedQueue.wait();
					// control appears here after notifyAll()
					if(! DaemonThread.alive) {
						return null;
					}
				}
			}
			//Otherwise consume element and notify waiting producer
			synchronized (sharedQueue) {
				Socket clientSocket = null;
				//System.out.println(" [Output from log4j] Entering sync dequeue function ");
				clientSocket = (Socket) sharedQueue.remove(0);
				sharedQueue.notify();
				//logger.info(" [Output from log4j] Client socket dequeued for processing " + clientSocket);
				//System.out.println(" [Output from log4j] Client socket dequeued for processing " + clientSocket);
				return clientSocket;
			}
		}
		catch (Exception e) {
			//logger.error(" [Output from log4j] Error from dequeue function " + e);
			//System.err.println(" [Output from log4j] Error from dequeue function " + e);
			//e.printStackTrace();
			return null;
		}
	}

	public void run() {
		// write code to read from queue and call function to process request
		// change method to call processRequest in synchronized loop
		try{
			while (DaemonThread.alive){
				try{
					Socket clientSocket = null;
					//System.out.println(" [Output from log4j] Before entering the dequeue function ");
					clientSocket = readFromQueue();
					if(clientSocket == null && !(DaemonThread.alive)) {
						//System.out.println(" [Output from log4j] End of run function for Worker Thread");
						return;
					}
					//System.out.println(" [Output from log4j] Before entering the process Request Function ");
					this.processRequest(clientSocket);

					//closing the socket after processing of request
					try{
						//System.out.println(" [Output from log4j] Closing client Socket after processing request ");
						clientSocket.close();
						//System.out.println(" [Output from log4j] After Closing Socket ");
					}
					catch (Exception ex){
						//logger.error(" [Output from log4j] Error closing client Socket " + ex);
						//System.err.println(" [Output from log4j] Error closing client Socket " + ex);
						ex.printStackTrace();
					}
				}
				catch(Exception e){
					//logger.error(" [Output from log4j] Error dequeuing client request " + e);
					//System.err.println(" [Output from log4j] Error dequeuing client request " + e);
					//e.printStackTrace();
				}
			}
			//System.out.println(" [Output from log4j] End of run function for Worker Thread");
		}
		catch (Exception e){
			//logger.error(" [Output from log4j] Error while exiting Run function for Worker Thread " + e);
			//System.err.println(" [Output from log4j] Error while exiting Run function for Worker Thread " + e);
			//e.printStackTrace();
		}
	}

	public void processRequest(Socket clientSocket) {
		// write code to process the incoming requests
		//logger.info(" [Output from log4j] Entering processRequest function");
		//System.out.println(" [Output from log4j] Entering processRequest function");

		BufferedReader brObj = null;
		StringBuffer requestData = new StringBuffer("");
		try {
			brObj = new BufferedReader (new InputStreamReader (clientSocket.getInputStream()));
			String line = null;
			while ((line=brObj.readLine()).length() != 0){
				//logger.info(" [Output from log4j] Data Received for processing "+ line.toString());
				//System.out.println(" [Output from log4j] Data Received for processing "+ line.toString());
				requestData.append(line + "\t");
			}	
			//logger.info(" [Output from log4j] Data from Input Reader captured.");
			//System.out.println(" [Output from log4j] Data from Input Reader captured.");
		}
		catch (IOException e) {
			////e.printStackTrace();
			//logger.error(" [Output from log4j] Error reading client request " + e);
			//System.err.println(" [Output from log4j] Error reading client request " + e);
			//e.printStackTrace();
		}
		// to close connection if the data is empty in the clientSocket
		if (requestData.equals("")){
			return;
		}

		//logger.info(" [Output from log4j] Client Socket Data for processing " + requestData);
		//System.out.println(" [Output from log4j] Client Socket Data for processing " + requestData);

		boolean isCorrect = this.hashRequestData(requestData.toString(), clientSocket);
		if(isCorrect){ 
			this.createRespone(clientSocket);
		}
		return;
	}

	public void createRespone (Socket clientSocket) {
		// fetch values from HashMap
		String requestMethod = null;
		String requestPath = null;
		String requestVersion = null;
		try{
			for (@SuppressWarnings("rawtypes") Map.Entry map: this.mapRequestData.entrySet()){
				if((String) map.getKey() == "Method"){
					requestMethod = map.getValue().toString();
					//logger.info(" [Output from log4j] Data captured for Response Header : Method : " + requestMethod );
					//System.out.println(" [Output from log4j] Data captured for Response Header : Method : " + requestMethod );
				}
				else if((String) map.getKey() == "Path"){
					requestPath = map.getValue().toString();
					//logger.info(" [Output from log4j] Data captured for Response Header : Path : " + requestPath );
					//System.out.println(" [Output from log4j] Data captured for Response Header : Path : " + requestPath );
				}
				else if((String) map.getKey() == "Version"){
					requestVersion = map.getValue().toString();
					//logger.info(" [Output from log4j] Data captured for Response Header : Version : " + requestVersion );
					//System.out.println(" [Output from log4j] Data captured for Response Header : Version : " + requestVersion );
				}
			}

			// creating Hash Map to store values for Thread and corresponding Path
			Thread currentThread = Thread.currentThread();
			DaemonThread.mapThreadRequestData.put(currentThread.getName(), requestPath);

			if (requestMethod.toLowerCase().equals("get") || requestMethod.toLowerCase().equals("head")){
				if (requestMethod.toLowerCase().equals("head")){
					isHead = true;
				}
				else {
					isGet = true;
				}
				String hostName = null;
				// for compliance with HTTP 1.1 requests
				if(requestVersion.equalsIgnoreCase("HTTP/1.1")) {
					isHTTPLatest = true;
					if((this.mapRequestData.containsKey("Expect"))) {
						isExpect = true;
					}
					if (! this.mapRequestData.containsKey("Host")){
						//System.err.println(" [Output from log4j] Error while loading the requested file : Bad Request");
						int errorStatusCode = 400;  
						this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
					}
					else if (this.mapRequestData.containsKey("Host")){ 
						if ((hostName = this.mapRequestData.get("Host")).length() == 0){
							int errorStatusCode = 400;  
							this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
						}
						else {
							//System.out.println(" [Output from log4j] Entering loop after host check");
							// check scenarios for if-modified-since
							if(isGet) {
								if(this.mapRequestData.containsKey("If-Modified-Since") && this.mapRequestData.containsKey("If-Unmodified-Since")) {
									//System.err.println(" [Output from log4j] Error while loading the requested file : BAD Request");
									int errorStatusCode = 400;  
									this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
								}
								else if (this.mapRequestData.containsKey("If-Modified-Since")) {
									//String modifiedDate = this.mapRequestData.get("If-Modified-Since");
									isModified = true;
									this.fetchRequestForm(requestPath, requestVersion, clientSocket);
								}
								else if (this.mapRequestData.containsKey("If-Unmodified-Since")) {
									//String unmodifiedDate = this.mapRequestData.get("If-Unmodified-Since");
									isUnmodified = true;
									this.fetchRequestForm(requestPath, requestVersion, clientSocket);
								}
								else {
									this.fetchRequestForm(requestPath, requestVersion, clientSocket);
								}
							}
							else {
								if (this.mapRequestData.containsKey("If-Unmodified-Since")) { 
									isUnmodified = true;
									this.fetchRequestForm(requestPath, requestVersion, clientSocket);
								}
								else {
									this.fetchRequestForm(requestPath, requestVersion, clientSocket);
								}
							}

						}
					}
				}
				else{
					this.fetchRequestForm(requestPath, requestVersion, clientSocket);
				}
			}
			else {
				// handle error case for Not Implemented
				//System.err.println(" [Output from log4j] Error while loading the requested file : FILE NOT FOUND");
				int errorStatusCode = 501;  
				this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
			}
		}
		catch(Exception e){
			//logger.error(" [Output from log4j] Error While capturing data for Response Header " + e );
			//System.err.println(" [Output from log4j] Error While capturing data for Response Header " + e );
			//e.printStackTrace();
		}
	}

	@SuppressWarnings("deprecation")
	public void fetchRequestForm (String requestPath , String requestVersion , Socket clientSocket){
		String absoluteFilePath = null;
		requestPath = requestPath.replace("%20", " ");
		int errorStatusCode; 
		try {
			if(requestPath.length() == 0 ){
				// call function to recursively call and get contents of root directory.
				int defaultDirType = 1;
				absoluteFilePath = DaemonThread.homeDirectory + "/";

				if (isModified) {
					String modifiedDate = this.mapRequestData.get("If-Modified-Since");
					String compareModifiedDate = this.updateDateFormat(modifiedDate);
					// get last modified date for a directory
					File fdir = new File (absoluteFilePath);
					SimpleDateFormat sdf = new SimpleDateFormat("EEE,dd MMM yyyy HH:mm:ss");
					String fileModifiedDate = sdf.format(fdir.lastModified()).toString() + "GMT";

					// write code to compare dates and proceed
					try{
						Date dHeadDate = sdf.parse(compareModifiedDate);
						Date dFileDate = sdf.parse(fileModifiedDate);
						if (dHeadDate.compareTo(dFileDate) <= 0) {
							this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
						}
						else {
							//System.err.println(" [Output from log4j] Error with If Modified Since");
							errorStatusCode = 304;  
							this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);

						}
					}
					catch (Exception ex) {
						//logger.error(" [Output from log4j] Error while comparing dates " + ex );
						//System.err.println(" [Output from log4j] Error while comparing dates " + ex );
						ex.printStackTrace();
					}
				}
				else if (isUnmodified) {
					String unmodifiedDate = this.mapRequestData.get("If-Unmodified-Since");
					String compareUnmodifiedDate = this.updateDateFormat(unmodifiedDate);
					// get last modified date for a directory
					File fdir = new File (absoluteFilePath);
					SimpleDateFormat sdf = new SimpleDateFormat("EEE,dd MMM yyyy HH:mm:ss");
					String fileModifiedDate = sdf.format(fdir.lastModified()).toString() + "GMT";

					// write code to compare dates and proceed
					try{
						Date dHeadDate = sdf.parse(compareUnmodifiedDate);
						Date dFileDate = sdf.parse(fileModifiedDate);
						if (dHeadDate.compareTo(dFileDate) >= 0) {
							this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
						}
						else {
							//System.err.println(" [Output from log4j] Error with If UnModified Since");
							errorStatusCode = 412;  
							this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);

						}
					}
					catch (Exception ex) {
						//logger.error(" [Output from log4j] Error while comparing dates " + ex );
						//System.err.println(" [Output from log4j] Error while comparing dates " + ex );
						ex.printStackTrace();
					}

				}
				else {
					this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
				}
				// check where to call this function 
				// this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
			}
			else if (requestPath.length() == 1 ){
				if (requestPath.equals("/")){
					// call function to recursively call and get contents of root directory.
					int defaultDirType = 1;
					absoluteFilePath = DaemonThread.homeDirectory + requestPath;

					if (isModified) {
						String modifiedDate = this.mapRequestData.get("If-Modified-Since");
						String compareModifiedDate = this.updateDateFormat(modifiedDate);
						// get last modified date for a directory
						File fdir = new File (absoluteFilePath);
						SimpleDateFormat sdf = new SimpleDateFormat("EEE,dd MMM yyyy HH:mm:ss");
						String fileModifiedDate = sdf.format(fdir.lastModified()).toString() + "GMT";

						// write code to compare dates and proceed
						try{
							Date dHeadDate = sdf.parse(compareModifiedDate);
							Date dFileDate = sdf.parse(fileModifiedDate);
							if (dHeadDate.compareTo(dFileDate) <= 0) {
								this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
							}
							else {
								//System.err.println(" [Output from log4j] Error with If Modified Since");
								errorStatusCode = 304;  
								this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
							}
						}
						catch (Exception ex) {
							//logger.error(" [Output from log4j] Error while comparing dates " + ex );
							//System.err.println(" [Output from log4j] Error while comparing dates " + ex );
							ex.printStackTrace();
						}

					}
					else if (isUnmodified) {
						String unmodifiedDate = this.mapRequestData.get("If-Unmodified-Since");
						String compareUnmodifiedDate = this.updateDateFormat(unmodifiedDate);
						// get last modified date for a directory
						File fdir = new File (absoluteFilePath);
						SimpleDateFormat sdf = new SimpleDateFormat("EEE,dd MMM yyyy HH:mm:ss");
						String fileModifiedDate = sdf.format(fdir.lastModified()).toString() + "GMT";

						// write code to compare dates and proceed
						// write code to compare dates and proceed
						try{
							Date dHeadDate = sdf.parse(compareUnmodifiedDate);
							Date dFileDate = sdf.parse(fileModifiedDate);
							if (dHeadDate.compareTo(dFileDate) >= 0) {
								this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
							}
							else {
								//System.err.println(" [Output from log4j] Error with If UnModified Since");
								errorStatusCode = 412;  
								this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);

							}
						}
						catch (Exception ex) {
							ex.printStackTrace();
							//logger.error(" [Output from log4j] Error while comparing dates " + ex );
							//System.err.println(" [Output from log4j] Error while comparing dates " + ex );
						}
					}
					else {
						this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
					}

					//this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
				}
			}
			else {
				boolean isSpecialCase = false;
				if (requestPath.equalsIgnoreCase("/shutdown")) {
					// function to call graceful shutdown to the system!!
					isSpecialCase = true;
					this.createShutdownResponse(absoluteFilePath, requestVersion, clientSocket);
					this.implementShutDown();
				}
				else if (requestPath.equalsIgnoreCase("/control")) {
					// function to display the control panel for the server..
					isSpecialCase = true;
					this.fetchControlPanel(requestVersion, clientSocket);
				}
				if (! isSpecialCase ){
					absoluteFilePath = DaemonThread.homeDirectory + requestPath;
					boolean isExist = true;
					if (! (new File(absoluteFilePath).exists()) ) {
						// call function to generate File Not Found Error
						//System.err.println(" [Output from log4j] Error while loading the requested file : FILE NOT FOUND");
						errorStatusCode = 404;  
						this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
						isExist = false;
					}
					if(isExist){
						if ( new File(absoluteFilePath).isDirectory() ){
							// call function  to get contents of the current directory
							int defaultDirType = 0;

							if (isModified) {
								String modifiedDate = this.mapRequestData.get("If-Modified-Since");
								String compareModifiedDate = this.updateDateFormat(modifiedDate);
								// get last modified date for a directory
								File fdir = new File (absoluteFilePath);
								SimpleDateFormat sdf = new SimpleDateFormat("EEE,dd MMM yyyy HH:mm:ss");
								String fileModifiedDate = sdf.format(fdir.lastModified()).toString() + "GMT";

								// write code to compare dates and proceed
								try{
									Date dHeadDate = sdf.parse(compareModifiedDate);
									Date dFileDate = sdf.parse(fileModifiedDate);
									if (dHeadDate.compareTo(dFileDate) <= 0) {
										this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
									}
									else {
										//System.err.println(" [Output from log4j] Error with If Modified Since");
										errorStatusCode = 304;  
										this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);

									}
								}
								catch (Exception ex) {
									//logger.error(" [Output from log4j] Error while comparing dates " + ex );
									//System.err.println(" [Output from log4j] Error while comparing dates " + ex );
									ex.printStackTrace();
								}
							}
							else if (isUnmodified) {
								String unmodifiedDate = this.mapRequestData.get("If-Unmodified-Since");
								String compareUnmodifiedDate = this.updateDateFormat(unmodifiedDate);
								// get last modified date for a directory
								File fdir = new File (absoluteFilePath);
								SimpleDateFormat sdf = new SimpleDateFormat("EEE,dd MMM yyyy HH:mm:ss");
								String fileModifiedDate = sdf.format(fdir.lastModified()).toString() + "GMT";

								// write code to compare dates and proceed
								// write code to compare dates and proceed
								try{
									Date dHeadDate = sdf.parse(compareUnmodifiedDate);
									Date dFileDate = sdf.parse(fileModifiedDate);
									if (dHeadDate.compareTo(dFileDate) >= 0) {
										this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
									}
									else {
										//System.err.println(" [Output from log4j] Error with If UnModified Since");
										errorStatusCode = 412;  
										this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);

									}
								}
								catch (Exception ex) {
									//logger.error(" [Output from log4j] Error while comparing dates " + ex );
									//System.err.println(" [Output from log4j] Error while comparing dates " + ex );
									ex.printStackTrace();
								}
							}
							else {
								this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
							}

							// this.getDirectoryContents(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket, defaultDirType);
						}
						else if ( new File(absoluteFilePath).isFile() ){
							// call function to get contents of file

							if (isModified) {
								String modifiedDate = this.mapRequestData.get("If-Modified-Since");
								String compareModifiedDate = this.updateDateFormat(modifiedDate);
								// get last modified date for a directory
								File fdir = new File (absoluteFilePath);
								SimpleDateFormat sdf = new SimpleDateFormat("EEE,dd MMM yyyy HH:mm:ss");
								String fileModifiedDate = sdf.format(fdir.lastModified()).toString() + "GMT";

								// write code to compare dates and proceed
								try{
									Date dHeadDate = sdf.parse(compareModifiedDate);
									Date dFileDate = sdf.parse(fileModifiedDate);
									if (dHeadDate.compareTo(dFileDate) <= 0) {
										this.createFileResponse(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket);
									}
									else {
										//System.err.println(" [Output from log4j] Error with If Modified Since");
										errorStatusCode = 304;  
										this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);

									}
								}
								catch (Exception ex) {
									//logger.error(" [Output from log4j] Error while comparing dates " + ex );
									//System.err.println(" [Output from log4j] Error while comparing dates " + ex );
									ex.printStackTrace();
								}
							}
							else if (isUnmodified) {
								String unmodifiedDate = this.mapRequestData.get("If-Unmodified-Since");
								String compareUnmodifiedDate = this.updateDateFormat(unmodifiedDate);
								// get last modified date for a directory
								File fdir = new File (absoluteFilePath);
								SimpleDateFormat sdf = new SimpleDateFormat("EEE,dd MMM yyyy HH:mm:ss");
								String fileModifiedDate = sdf.format(fdir.lastModified()).toString() + "GMT";

								// write code to compare dates and proceed
								// write code to compare dates and proceed
								try{
									Date dHeadDate = sdf.parse(compareUnmodifiedDate);
									Date dFileDate = sdf.parse(fileModifiedDate);
									if (dHeadDate.compareTo(dFileDate) >= 0) {
										this.createFileResponse(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket);
									}
									else {
										//System.err.println(" [Output from log4j] Error with If UnModified Since");
										errorStatusCode = 412;  
										this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);

									}
								}
								catch (Exception ex) {
									//logger.error(" [Output from log4j] Error while comparing dates " + ex );
									//System.err.println(" [Output from log4j] Error while comparing dates " + ex );
									ex.printStackTrace();
								}
							}
							else {
								this.createFileResponse(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket);
							}
							//this.createFileResponse(URLDecoder.decode(absoluteFilePath), requestVersion, clientSocket);
						}
					}
				}
			}
		}
		catch ( Exception e ) {
			//logger.error(" [Output from log4j] Error while checking type of request path " + e);
			//System.err.println(" [Output from log4j] Error while checking type of request path " + e);
			//e.printStackTrace();
		}
	}

	public void implementShutDown(){
		DaemonThread.alive = false;
		try {
			DaemonThread.serverSocket.close();
		}
		catch (Exception e) {
			//logger.error(" [Output from log4j] Error while closing Server Socket " + e);
			//System.err.println(" [Output from log4j] Error while closing Server Socket " + e);
			//e.printStackTrace();
		}
	}

	public void fetchControlPanel (String requestVersion , Socket clientSocket) {
		try{
			// creating header for control panel 
			String htmlResponse = "<!DOCTYPE html><html><head><title>My Control Panel</title></head><body>";
			htmlResponse += "<font color = '#660033'><h1 align='middle'>ERIS 1.0</h1><hr></font>";
			htmlResponse += "<p><font color = '#0033CC'>";
			htmlResponse += "<h4 align='middle' padding = '0' margin = '0'>Server Owner : Aakriti Singla<br/>";
			htmlResponse += "SEAS Login Account : aakritis@seas.upenn.edu</h4><hr>";

			// starting display for thread details 
			htmlResponse += "<br/>";
			htmlResponse += "<table style = 'width:100%; height:100%'> <tr>";
			htmlResponse += "<td align = 'center'>Thread-Name</td> <td align = 'center'>Thread-Current-State</td><td align = 'center'>Thread-Request-Url</td></tr>";

			// accessing Thread Pool Data through Iterator Class
			@SuppressWarnings("rawtypes")
			Iterator iThread = DaemonThread.threadPool.iterator();
			while (iThread.hasNext()){
				htmlResponse += "<tr>";
				Thread thread = (Thread) iThread.next();
				String threadName = thread.getName();
				State threadState = thread.getState();
				int state = 0;
				String threadURL = "No Request";
				if(threadState.toString().toLowerCase().equals("runnable")){
					state = 1;
					threadURL = DaemonThread.mapThreadRequestData.get(threadName);
				}
				else{
					state = 0;
				}
				if( state == 1){
					htmlResponse += "<td align = 'center'><font color = '#009933'>" + threadName + "</font></td><td align = 'center'><font color = '#009933'>" + threadState + "</font></td><td align = 'center'><font color = '#009933'>" + threadURL + "</font></td></tr>";
				}
				else{
					htmlResponse += "<td align = 'center'><font color = '#FF5050'>" + threadName + "</font></td><td align = 'center'><font color = '#FF5050'>" + threadState + "</font></td><td align = 'center'><font color = '#FF5050'>" + threadURL +"</font></td></tr>";
				}
			}		
			htmlResponse += "</p></table><br/><br/>";
			String localAddress = InetAddress.getLocalHost().getHostAddress();
			String displayURL = "http://" + localAddress + ":" + DaemonThread.serverPort + "/shutdown";
			htmlResponse += "<center><h3><a href = ' " + displayURL + "'> SHUT DOWN </a></h3></center><br/><br/>";
			htmlResponse += "</font></body></html>";
			byte [] defaultHTMLBytes = new byte[(int)htmlResponse.length()];
			defaultHTMLBytes = htmlResponse.getBytes();

			// update contentLength 
			int contentLength = htmlResponse.length();
			String contentType = "text/html";
			//Date currentDate = new Date();
			//String date = currentDate.toString();
			String date = this.getCurrentDate();

			String responseHeader = "";
			if (isExpect) {
				responseHeader += requestVersion + "100 Continue\r\n";
			}
			responseHeader += requestVersion + " 200 OK\r\n" + "Date: " + date + "\r\n" + "Content-Type: " + contentType + "\r\n" + "Content-Length: " + contentLength + "\r\n" + "Connection: close\r\n" + "\n";
			//System.out.println(" [Output from log4j] Response Header : " + responseHeader);

			DataOutputStream dout = new DataOutputStream (clientSocket.getOutputStream());
			dout.writeUTF(responseHeader);
			if (! isHead){
				dout.write(defaultHTMLBytes);
			}
			dout.flush();
			dout.close();		
		}
		catch (Exception e) {
			//logger.error(" [Output from log4j] Error while displaying contents of Control Page " + e );
			//System.err.println(" [Output from log4j] Error while displaying contents of Control Page " + e );
			//e.printStackTrace();
		}
	}

	public String getCurrentDate(){
		try{
			SimpleDateFormat formatDate = new SimpleDateFormat("EEE,dd MMM yyyy HH:mm:ss");
			formatDate.setTimeZone(TimeZone.getTimeZone("GMT"));
			String currentDate = formatDate.format(new Date()).toString()+" GMT";
			return currentDate;
		}
		catch(Exception e){
			//e.printStackTrace();
			return null;
		}
	}

	public String updateDateFormat(String requestDate) {
		String finalDate = null;
		try{
			if (requestDate.contains(",") && requestDate.contains("-")) {
				//Type 2 Date Format
				String[] spaceSplit = requestDate.split(" ");
				if(spaceSplit.length == 4) {
					String[] dateSplit = spaceSplit[1].split("-");
					if(dateSplit.length == 3) {
						String year = null;
						if ( Integer.parseInt(dateSplit[2]) <=65 ){
							year = "20" + dateSplit[2];
						}
						else {
							year = "19" + dateSplit[2];
						}
						finalDate = spaceSplit[0].substring(0,3) + ", " + dateSplit[0] + " " + dateSplit[1] + " " + year + " " + spaceSplit[2] + " GMT";
					}
				}
			}
			else if (requestDate.contains(",")) {
				// Type 1 Date Format
				finalDate = requestDate;
			}
			else {
				// Type 3 Date Format
				String[] dateParts = requestDate.split(" ");
				if(dateParts.length == 5) { 
					finalDate = dateParts[0] + ", " + dateParts[2] + " " + dateParts[1] + " " + dateParts[4] + " " + dateParts[3] + " GMT";
				}
			}
			//logger.info(" [Output from log4j] Date Format for If-Modified-Since / If-Unmodified-since " + finalDate );
			//System.out.println(" [Output from log4j] Date Format for If-Modified-Since / If-Unmodified-since " + finalDate );
		}
		catch(Exception e ) {
			//logger.error(" [Output from log4j] Error : Date Format for If-Modified-Since / If-Unmodified-since " + finalDate );
			//System.err.println(" [Output from log4j] Error : Date Format for If-Modified-Since / If-Unmodified-since " + finalDate );
			//e.printStackTrace();
		}
		return finalDate;
	}

	// check for forbidden access error
	public void getDirectoryContents ( String absoluteFilePath, String requestVersion , Socket clientSocket , int defaultDirType) {
		try{
			File directoryPath = new File (absoluteFilePath);
			String directoryActualPath = directoryPath.getCanonicalPath();
			if (!(directoryActualPath.startsWith(DaemonThread.homeDirectory))) {
				int errorStatusCode = 403;  
				this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
			}
			else {
				String dirPath = directoryPath.getCanonicalPath();
				String[] dirName = dirPath.split("/");
				File[] directoryContent = directoryPath.listFiles();
				// creating response page for listing directory contents 
				String htmlResponse = "<!DOCTYPE html><html><head><title>My Directory Listing</title></head><body><font color = '#0033CC'>";
				boolean isBackButton = true;
				if(defaultDirType == 1){
					htmlResponse = htmlResponse + "<h2 align='middle'>Directory Listing For : ROOT" + "</h2>" + "<hr>";
					isBackButton = false;
				}
				else{
					htmlResponse = htmlResponse + "<h2 align ='middle'>Directory Listing For : " + dirName[dirName.length - 1] + "</h2>" + "<hr>";		
				}
				htmlResponse = htmlResponse + "<br/><p><h4>";
				if(isBackButton){
					String previousDirPath = dirPath.replace(dirName[(dirName.length-1)], "");
					previousDirPath = previousDirPath.replace(DaemonThread.homeDirectory, "");
					String localAddress = InetAddress.getLocalHost().getHostAddress();
					String displayURL = "http://" + localAddress + ":" + DaemonThread.serverPort + previousDirPath;
					htmlResponse += "<a href = ' " + displayURL + "'>Back</a><br/><br/>";
				}

				for ( File file : directoryContent ) {
					String filePath = file.getCanonicalPath();
					String[] name = filePath.split("/");
					if(file.isDirectory()) {
						htmlResponse = htmlResponse + "<font color = '#009933'>Sub-Directory : ";
						// create reference link

						String subFilePath = filePath.replace(DaemonThread.homeDirectory, "");
						//subFilePath = URLEncoder.encode(subFilePath, "UTF-8");
						//subFilePath = URLEncoder.encode(subFilePath);
						String localAddress = InetAddress.getLocalHost().getHostAddress();
						String displayURL = "http://" + localAddress + ":" + DaemonThread.serverPort + subFilePath;
						htmlResponse = htmlResponse + "<a href = '" + displayURL + "'>";
						htmlResponse = htmlResponse + name[name.length - 1] + "</a></font><br/>";
					}
					else{
						htmlResponse = htmlResponse + "<font color = '#FF5050'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File : ";
						htmlResponse = htmlResponse + name[name.length - 1] + "</font><br/>";
					}
				}
				htmlResponse = htmlResponse + "</h4></p></font></body></html>";

				byte [] defaultHTMLBytes = new byte[(int)htmlResponse.length()];
				defaultHTMLBytes = htmlResponse.getBytes();

				// update contentLength 
				int contentLength = htmlResponse.length();
				String contentType = "text/html";
				//Date currentDate = new Date();
				//String date = currentDate.toString();
				String date = this.getCurrentDate();

				String responseHeader = "";
				if (isExpect) {
					responseHeader += requestVersion + "100 Continue\r\n";
				}
				responseHeader += requestVersion + " 200 OK\r\n" + "Date: " + date + "\r\n" + "Content-Type: " + contentType + "\r\n" + "Content-Length: " + contentLength + "\r\n" + "Connection: close\r\n" + "\n";
				//System.out.println(" [Output from log4j] Response Header : " + responseHeader);

				DataOutputStream dout = new DataOutputStream (clientSocket.getOutputStream());
				dout.writeUTF(responseHeader);
				if(! isHead){
					dout.write(defaultHTMLBytes);
				}
				dout.flush();
				dout.close();	
			}
		}
		catch (Exception e){
			//logger.error(" [Output from log4j] Error while displaying contents of requested directory " + e );
			//System.err.println(" [Output from log4j] Error while displaying contents of requested directory " + e );
			//e.printStackTrace();
		}
	}

	public void createErrorResponse ( int errorStatusCode, String requestVersion, Socket clientSocket ) {
		try{
			String contentType = "text/html";
			//Date currentDate = new Date();
			//String date = currentDate.toString();
			String date = this.getCurrentDate();
			String errorStatusMsg = null;
			int contentLength = 0;

			switch (errorStatusCode) {
			case 404 :
				errorStatusMsg = "Not Found";
				break;
			case 403 :
				errorStatusMsg = "Forbidden";
				break;
			case 501 :
				errorStatusMsg = "Not Implemented";
				break;
			case 505 :
				errorStatusMsg = "HTTP Version Not Supported";
				break;
			case 400 :
				errorStatusMsg = "Bad Request";
				break;
			case 412 :
				errorStatusMsg = "Precondition Failed";
				break;
			case 304 :
				errorStatusMsg = "Not Modified";
				break;
			} 

			// create HTML response 
			String htmlResponse = "<!DOCTYPE html><html><head><title>Error Page</title></head><body><font color = '#0033CC'><h1>HTTP Error " + errorStatusCode +" </h1><br/><h2>"+ errorStatusCode + " " + errorStatusMsg +"</h2></font></body></html>";
			byte [] defaultHTMLBytes = new byte[(int)htmlResponse.length()];
			defaultHTMLBytes = htmlResponse.getBytes();
			//System.out.println(" [Output from log4j] Response HTML : " + htmlResponse );
			contentLength = htmlResponse.length();
			String responseHeader = "";
			if (isExpect) {
				responseHeader += requestVersion + "100 Continue\r\n";
			}
			responseHeader += requestVersion + " " + errorStatusCode + " " + errorStatusMsg + "\r\n" + "Date: " + date + "\r\n" + "Content-Type: " + contentType + "\r\n" + "Content-Length: " + contentLength + "\r\n" + "Connection: close\r\n" + "\n";
			//System.out.println(" [Output from log4j] Response Header : " + responseHeader);

			DataOutputStream dout = new DataOutputStream (clientSocket.getOutputStream());
			dout.writeUTF(responseHeader);
			if (! isHead) {
				dout.write(defaultHTMLBytes);
			}
			dout.flush();
			dout.close();		
		}
		catch ( Exception e ) {
			//logger.error(" [Output from log4j] Error while creating Error Response " + e );
			//System.err.println(" [Output from log4j] Error while creating Error Response " + e );
			//e.printStackTrace();
		}
	}

	public void createShutdownResponse ( String absoluteFilePath , String requestVersion , Socket clientSocket ) {
		try {
			String contentType = "text/html";
			String date = this.getCurrentDate();
			String errorStatusMsg = null;
			int contentLength = 0;
			String htmlResponse = "<!DOCTYPE html><html><head><title>Shutdown Page</title></head><body><font color = '#0033CC'><h1></h1><br/><h1>"+ "Shutting Down The Server...." +"</h1></font></body></html>";
			byte [] defaultHTMLBytes = new byte[(int)htmlResponse.length()];
			defaultHTMLBytes = htmlResponse.getBytes();
			//System.out.println(" [Output from log4j] Response HTML : " + htmlResponse );
			contentLength = htmlResponse.length();
			String responseHeader = "";
			if (isExpect) {
				responseHeader += requestVersion + "100 Continue\r\n";
			}
			responseHeader += requestVersion + " " + "200 OK" + "\r\n" + "Date: " + date + "\r\n" + "Content-Type: " + contentType + "\r\n" + "Content-Length: " + contentLength + "\r\n" + "Connection: close\r\n" + "\n";
			//System.out.println(" [Output from log4j] Response Header : " + responseHeader);

			DataOutputStream dout = new DataOutputStream (clientSocket.getOutputStream());
			dout.writeUTF(responseHeader);
			if (! isHead) {
				dout.write(defaultHTMLBytes);
			}
			dout.flush();
			dout.close();		

		}
		catch (Exception e) {
			//logger.error(" [Output from log4j] Error while creating file response " + e);
			//System.err.println(" [Output from log4j] Error while creating file response " + e);
			//e.printStackTrace();
		}
	}

	// check code for forbidden access error 
	public void createFileResponse ( String absoluteFilePath , String requestVersion , Socket clientSocket ) {
		try {
			File fileRead = new File (absoluteFilePath);
			//System.out.println(" [Output from log4j] Absolute File Path : " + absoluteFilePath);
			// if-else loop for forbidden access error 
			String fileActualPath = fileRead.getCanonicalPath();
			if (!(fileActualPath.startsWith(DaemonThread.homeDirectory))) {
				int errorStatusCode = 403;  
				this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
			}
			else {
				if(fileRead.canRead()){
					// reading the requested resource 
					@SuppressWarnings("resource")
					FileInputStream fileStream = new FileInputStream (absoluteFilePath);
					//byte[] fileBytes = new byte[fileStream.available()];
					byte[] fileBytes = new byte[(int)fileRead.length()];
					//System.out.println(" [Output from log4j] FileStream Length : " + fileBytes.length);
					//System.out.println(" [Output from log4j] File Length : " + fileRead.length());
					fileStream.read(fileBytes);

					//String fileContent = new String (fileBytes);
					//System.out.println(" [Output from log4j] File Content : " + fileBytes);

					// creating response header 
					String[] filePath = absoluteFilePath.split("\\.");
					//System.out.println(" [Output from log4j] FilePath Length : " + filePath.length);
					/*for (String check : filePath){
					System.out.println(" [Output from log4j] Array Element : " + check); 
				}*/
					String fileExtension = filePath [filePath.length - 1];

					FileTypes fileType = FileTypes.valueOf(fileExtension) ;
					String contentType = null;

					switch (fileType) {
					case jpg:
						contentType = "image/jpeg";
						break;
					case png:
						contentType = "image/png";
						break;
					case gif:
						contentType = "image/gif";
						break;
					case txt:
						contentType = "text/plain";
						break;
					case html:
						contentType = "text/html";
						break;
					default:
						contentType = "invalidtype";
						break;
					}

					int contentLength = fileBytes.length;
					//Date currentDate = new Date();
					//String date = currentDate.toString();
					String date = this.getCurrentDate();

					String responseHeader = "";
					if (isExpect) {
						responseHeader += requestVersion + "100 Continue\r\n";
					}
					responseHeader += requestVersion + " 200 OK\r\n" + "Date: " + date + "\r\n" + "Content-Type: " + contentType + "\r\n" + "Content-Length: " + contentLength + "\r\n" + "Connection: close\r\n" + "\n";
					//System.out.println(" [Output from log4j] Response Header : " + responseHeader);
					// returning data to Socket
					DataOutputStream dout = new DataOutputStream (clientSocket.getOutputStream());
					dout.writeUTF(responseHeader);
					if (! isHead) {
						dout.write(fileBytes);
					}
					dout.flush();
					dout.close();
				}
				else {
					// call function to create Permission denied error
					int errorStatusCode = 403;
					this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
				}
			}
		}
		catch (Exception e) {
			//logger.error(" [Output from log4j] Error while creating file response " + e);
			//System.err.println(" [Output from log4j] Error while creating file response " + e);
			//e.printStackTrace();
		}
	}

	public boolean hashRequestData(String requestData, Socket clientSocket){
		mapRequestData = new HashMap<String,String> ();
		String[] requestLines = requestData.split("\t");
		boolean isCorrect = true;
		int iCount = 0;
		try{
			for (String retVal: requestLines){
				// logger.info(" [Output from log4j Hash Map split for processed data " + retVal);
				// System.out.println(" [Output from log4j Hash Map split for processed data " + retVal);
				iCount++;
				if(iCount == 1){
					// checking for multiple spaces in a get request 
					String[] subLine = retVal.split(" +");
					// case for proper request GET path HTTP/*.*
					if (subLine.length == 3) {
						if (subLine[2].toLowerCase().equals("http/1.0") || subLine[2].toLowerCase().equals("http/1.1")){
							this.mapRequestData.put("Method", subLine[0]);
							String requestPath = subLine[1];
							if (requestPath.startsWith("http")){
								URL urlObj = new URL (requestPath);
								this.mapRequestData.put("Path", urlObj.getPath());
								System.out.println(urlObj.getPath().toString());
							}
							else {
								this.mapRequestData.put("Path", subLine[1]);
							}
							this.mapRequestData.put("Version", subLine[2]);
							isCorrect = true;
						}
						// case where GET path HTTP/*.* but not proper HTTP/*.*
						else {
							// call function to display error page for HTTP incorrect
							int errorStatusCode = 505;
							String requestVersion = subLine[2];
							this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
							isCorrect = false;
						}
					}
					// case where improper request of length 1 or 3
					else if (subLine.length == 1 || subLine.length > 3) {
						// call function to display error page for Bad Request
						int errorStatusCode = 400;
						String requestVersion = "HTTP/1.1";
						this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
						isCorrect = false;
					}
					else if (subLine.length == 2){
						// catch 2 special cases 
						if (subLine[1].equalsIgnoreCase("/shutdown") || subLine[1].equalsIgnoreCase("/control")){
							this.mapRequestData.put("Method", subLine[0]);
							this.mapRequestData.put("Path", subLine[1]);
							this.mapRequestData.put("Version", "HTTP/1.1");
							isCorrect = true;	
						}
						else{
							// case where request like GET HTTP/*.*
							if (subLine[1].toLowerCase().equals("http/1.0") || subLine[1].toLowerCase().equals("http/1.1")){
								this.mapRequestData.put("Method", subLine[0]);
								this.mapRequestData.put("Path", "/");
								this.mapRequestData.put("Version", subLine[1]);
								isCorrect = true;
							}
							else {
								int errorStatusCode = 0;
								String requestVersion = null;
								if (subLine[1].contains("HTTP/")){
									errorStatusCode = 505;
									requestVersion = subLine[1];
									this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
								}
								else{
									errorStatusCode = 400;
									requestVersion = "HTTP/1.1";
									this.createErrorResponse(errorStatusCode, requestVersion, clientSocket);
								}
								isCorrect = false;
							}
						}
					}
				}
				else{
					String[] subLine = retVal.split(": ");
					// check process request data function
					if(subLine.length == 2){
						this.mapRequestData.put(subLine[0], subLine[1]);
					}
					else{
						//logger.info(" [Output from log4j Error in parsing of RequestData. Length of split " + subLine.length);
						//System.err.println(" [Output from log4j Error in parsing of RequestData. Length of split " + subLine.length);
					}
				}
			}
			//logger.info(" [Output from log4j] Hash Map created for storing processed data " + mapRequestData);
			//System.out.println(" [Output from log4j] Hash Map created for storing processed data " + mapRequestData);
		}
		catch (Exception e){
			//logger.error(" [Output from log4j] Error while creating Map for storing processed data " + e);
			//System.out.println(" [Output from log4j] Error while creating Map for storing processed data " + e);
			//e.printStackTrace();
			isCorrect = false;
		}
		return isCorrect;
	}
}
